# fenestrationController Embedded Application
An Arduino application, written in C++, which controls the electromechanical systems on the Fenestration Wall, including the relay controls, PID loops, sensor signal processing, and data logging. The application also hosts a Web Server that allows users to control the machine through HTTP requests, indended to be made primarilly through the WebApp (UI_Webpage). The application runs a multithreading architecture that allows it to perform its tasks asynchronously. This folder contains its own README.md.

### Files in this application
* **fenestrationController.ino:** The MAIN entry point of the application. Start reading here. This file spinns up the kernel (OSBos), initializes the various modules that run the system, registers the different necessary asynchronous threads and tasks with the kernel, and then polls the kernel in the loop() method. OSBos is a custom library for cooperative multithreading, and forms a key part of this application's architecture. You can find all the documentation on it on the GitHub page here: https://github.com/actuvon/OSBos
* **th_WebServer.h:** Outlines the interface for the WebServer thread. The web server thread needs to be initialized with th_WebServer::initialize() before it can run. The kernel calls the WebServer through its tick() function, which checks for incomming ethernet requests, reads them, takes necessary actions, and responds. The tick() function gets assigned as the root method in the Thread object, known to the outside world as th_WebServer::thread. That object gets added to the kernel, and the kernel looks at the root method to decide what to run, which is how it gets to the tick() function. This is a common pattern across the application. The WebServer internally depends on OSBos to be able to take actions asynchronously.
* **th_Blink.h/.cpp:** This shows an example for how to make a 'normal' asynchronous thread on OSBos. It blinks the yellow LED labeled "LED" on the P1AM-200 CPU on and off just like a normal Arduino blink example, except it uses OSBos to do it. I like keeping this running in the production version of the code so I can easily see that the code hasn't frozen up. This is the best place to look to help understand how OSBos is used in this application.
* **th_test.h:** This shows an example of how to make an asynchronous task for OSBos, which does a thing, finishes it, and then reports back and stops. This specific task turns a light on the CPU blue for a few seconds and then sets it back to normal. It's a good idea to look in here to get an idea of how OSBos works. You can play with this.
* **th_WebServer.cpp:** This has the guts of what the WebServer actually does when it receives an HTTP request. Any 'new thing' we want the WebServer to do has to get hooked up in here. Look at the initialize() function first. In here we declare what kinds of "paths" the server will accept, and what to do when it receives a request at each path. When we call Jarvis.On(path, handler), we tell the server to pass the incomming request over to that handler when it sees that incomming path. The WebApp is designed around 'widgets', which are these basic little UI building blocks that each have a relatively simple job. It's a good idea to take a look at the example widgets to read through and understand how they work. Basically, each widget in the HTML page should have a unique ID. When the user does a thing with a widget, that widget sends a request that looks like HTTP://\<server.ip.address>/WidgetID and that causes the server to see a path of "/WidgetID". We write Jarvis.On("/WidgetID", routes::WidgetHandler_Toggle("WidgetId")) in the initializer to tell the server to treat this request as a Toggle widget.  
All widgets have vales they need to GET from the system, and values they need to SET on the system. All the widget handler functions look to the functions GetWidgetStrVal(key) and SetWidgetVal(key, value) for instructions on hey to do their thing. For each widget you want to hook up, you'll have to write in the logic for how to get the widget's value from the system using its widget ID, and how to set the widget's value in the system using the widget ID. There are "success" bools that we can use to report back to the Web UI if there was a problem getting or setting a value.
* **MechanicalSystem.h/.cpp:** Here we define the interface for how to interact with the actual mechanical system from the rest of the codebase. There are a bunch of different kernel threads defined in here, each within their own namespace. This hosts the PID loops and other things needed to make stuff move around. Not EVERYTHING mechanical needs the higher level 'business logic' that lives here though. Simple things like turning blowers and pumps on and off can bypass this layer, going directly between the Web Server and the HAL.
* **HAL.h/.cpp:** The Hardware Abstraction Layer. This handles anything about the code that's hardware-specific. For example, instead of saying digitalWrite(pin, HIGH), we make a function setDigitalOutput(myOutput, state) and then in the .cpp we write the rules for how to handle each output. This makes it so that the rest of the application doesn't have to care whether it's dealing with an arduino pin, a P1 module, an RS232 thingy, some weird SPI doodad, etc... In theory, if we want to switch over to a totally different kind of microcontroller, we only need to change the HAL.cpp file and everything else in the entire application should still work. In practice, not EVERYTHING has been abstracted through the HAL. That takes time. It's rare to have a perfect HAL. For example, the WebServer assumes that we are using a MKR Ethernet shield. A perfect HAL would abstract that away so it doesn't matter what hardware our web stack is built on.
* **th_DataLogger.h/.cpp:** These files define and implement the thread responsible for running the Data Logger engine on the P1AM-200 CPU. This thread checks the critical sensors in the system, measures their values, and loggs that information in a row of text that gets stored on the SD card. There are also functions.
* **th_SerialConsole.h/.cpp:** These files set up a command-line-interface that runs on the P1AM-200 CPU through its USB port. It's the simplest way of running functions on the CPU from a PC terminal. It's designed to use the Arduino IDE's Serial Monitor, but it could be configured to work with PUTTY or something as well. This uses the SerialConsole library, which can be found with documentation and examples here: https://github.com/actuvon/SerialConsole
* **lib_Eth.h:** This is a custom toolkit to add some layers to the Arduino Ethernet library which let us run more advanced operations on the Ethernet shield. In here there are a few classes, structures, and helper messages that are used by the WebServer. I'll likely put the widget code in here and turn it into a library on Github one of these days.
* **lib_Utils.h:** This is boring. Basic helper tools for random stuff, like converting strings into floats with reasonable error handling capabilities.